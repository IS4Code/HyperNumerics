<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
using System;
using System.Collections;
using System.Collections.Generic;

namespace IS4.HyperNumerics.NumberTypes
{
<#
Func<string, string> emptyConstraints = fn => "";
var data = new[] {
	new{name = "BoxedNumber", args = "", hasinner = true, value = new[]{"Reference"}, constraints = emptyConstraints},
	new{name = "CustomDefaultNumber", args = "TTraits", hasinner = true, value = new[]{"Value"}, constraints = (Func<string, string>)(fn => " where TTraits : struct, " + fn + ".ITraits")},
	new{name = "GeneratedNumber", args = "", hasinner = true, value = new[]{"Generator()"}, constraints = emptyConstraints},
	new{name = "HyperComplex", args = "", hasinner = true, value = new[]{"first", "second"}, constraints = emptyConstraints},
	new{name = "HyperDiagonal", args = "", hasinner = true, value = new[]{"first", "second"}, constraints = emptyConstraints},
	new{name = "HyperDual", args = "", hasinner = true, value = new[]{"first", "second"}, constraints = emptyConstraints},
	new{name = "HyperSplitComplex", args = "", hasinner = true, value = new[]{"first", "second"}, constraints = emptyConstraints},
};
foreach(var info in data)
{
	bool hasinner = info.hasinner;
	bool primitive = true;
	string primitiveaffix = primitive ? ", TPrimitive" : "";
	string fullname = info.name;
	bool first = true;
	if(hasinner)
	{
		fullname += "<TInner";
		first = false;
	}
	if(primitive)
	{
		fullname += first ? "<" : ", ";
		fullname += "TPrimitive";
		first = false;
	}
	if(!String.IsNullOrEmpty(info.args))
	{
		fullname += first ? "<" : ", ";
		fullname += info.args;
		first = false;
	}
	if(!first)
	{
		fullname += ">";
	}
#>
	partial struct <#=fullname#> : IWrapperNumber<<#=fullname#>, <#=fullname#><#=primitiveaffix#>><#=
	hasinner ? primitive ? " where TInner : struct, INumber<TInner, TPrimitive>" : " where TInner : struct, INumber<TInner>" : ""
	#><#=
	primitive ? " where TPrimitive : struct, IEquatable<TPrimitive>, IComparable<TPrimitive>" : ""
	#><#=
	info.constraints(fullname)
	#>
	{
		partial class Operations : IExtendedNumberOperations<<#=fullname#>, <#=fullname#><#=primitiveaffix#>>
		{
			
		}
        
        static int GetCollectionCount<T>(in T value) where T : struct, ICollection<TPrimitive>
        {
            return value.Count;
        }

        static TPrimitive GetListItem<T>(in T value, int index) where T : struct, IList<TPrimitive>
        {
            return value[index];
        }

        static int GetReadOnlyCollectionCount<T>(in T value) where T : struct, IReadOnlyCollection<TPrimitive>
        {
            return value.Count;
        }

        static TPrimitive GetReadOnlyListItem<T>(in T value, int index) where T : struct, IReadOnlyList<TPrimitive>
        {
            return value[index];
        }
		
        int ICollection<TPrimitive>.Count => <#=String.Join(" + ", info.value.Select(v => "GetCollectionCount(" + v + ")"))#>;

        bool ICollection<TPrimitive>.IsReadOnly => true;

        int IReadOnlyCollection<TPrimitive>.Count => <#=String.Join(" + ", info.value.Select(v => "GetReadOnlyCollectionCount(" + v + ")"))#>;
		<# if(info.value.Length > 1) { #>
		
        TPrimitive IReadOnlyList<TPrimitive>.this[int index]
        {
            get{
                int offset = GetReadOnlyCollectionCount(first);
                if(index >= offset)
                {
                    return GetReadOnlyListItem(second, index - offset);
                }
                return GetReadOnlyListItem(first, index);
            }
        }

        TPrimitive IList<TPrimitive>.this[int index]
        {
            get{
                int offset = GetCollectionCount(first);
                if(index >= offset)
                {
                    return GetListItem(second, index - offset);
                }
                return GetListItem(first, index);
            }
            set{
                throw new NotSupportedException();
            }
        }

        int IList<TPrimitive>.IndexOf(TPrimitive item)
        {
            int index = first.IndexOf(item);
            if(index == -1)
            {
                int offset = GetCollectionCount(first);
                return offset + second.IndexOf(item);
            }
            return index;
        }<# }else if(info.value.Length == 1) { #>

        TPrimitive IReadOnlyList<TPrimitive>.this[int index]
        {
            get{
                return GetReadOnlyListItem(<#=info.value[0]#>, index);
            }
        }

        TPrimitive IList<TPrimitive>.this[int index]
        {
            get{
                return GetListItem(<#=info.value[0]#>, index);
            }
            set{
                throw new NotSupportedException();
            }
        }

        int IList<TPrimitive>.IndexOf(TPrimitive item)
        {
            return <#=info.value[0]#>.IndexOf(item);
        }<# } #>


        void IList<TPrimitive>.Insert(int index, TPrimitive item)
        {
            throw new NotSupportedException();
        }

        void IList<TPrimitive>.RemoveAt(int index)
        {
            throw new NotSupportedException();
        }

        void ICollection<TPrimitive>.Add(TPrimitive item)
        {
            throw new NotSupportedException();
        }

        void ICollection<TPrimitive>.Clear()
        {
            throw new NotSupportedException();
        }

        bool ICollection<TPrimitive>.Contains(TPrimitive item)
        {
            return <#=String.Join(" || ", info.value.Select(v => v + ".Contains(item)"))#>;
        }
		<# if(info.value.Length > 1) { #>
		
        void ICollection<TPrimitive>.CopyTo(TPrimitive[] array, int arrayIndex)
        {
			int offset = 0;<#
			foreach(var value in info.value)
			{
			#>

            <#=value#>.CopyTo(array, arrayIndex + offset);
			offset += GetCollectionCount(<#=value#>);<#
			}
			#>

        }<# }else if(info.value.Length == 1) { #>

        void ICollection<TPrimitive>.CopyTo(TPrimitive[] array, int arrayIndex)
        {
            <#=info.value[0]#>.CopyTo(array, arrayIndex);
        }<# } #>


        bool ICollection<TPrimitive>.Remove(TPrimitive item)
        {
            throw new NotSupportedException();
        }
		<# if(info.value.Length > 1) { #>

        IEnumerator<TPrimitive> IEnumerable<TPrimitive>.GetEnumerator()
        {<#
			foreach(var value in info.value)
			{
			#>

            foreach(var num in <#=value#>)
            {
                yield return num;
            }<#
			}
			#>

        }

        IEnumerator IEnumerable.GetEnumerator()
        {<#
			foreach(var value in info.value)
			{
			#>

            foreach(var num in <#=value#>)
            {
                yield return num;
            }<#
			}
			#>

        }<# }else if(info.value.Length == 1) { #>

        IEnumerator<TPrimitive> IEnumerable<TPrimitive>.GetEnumerator()
        {
			return <#=info.value[0]#>.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
			return <#=info.value[0]#>.GetEnumerator();
        }<# } #>

	}

<#
}
#>
}